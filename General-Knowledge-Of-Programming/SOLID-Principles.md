# SOLID 원칙

- 객체 지향 프로그래밍 및 설계의 5원칙에 앞글자를 따서 만든 단어이다.
- 객체 지향 프로그램에서 사용되는 디자인 패턴도 SOLID 원칙을 근거로 만들어 진 것이다.
- SOLID 원칙을 적용하면 유지보수와 확장이 용이한 프로그램을 만들 수 있다.
- 리팩토링의 지침으로서 사용되며, 애자일 개발 전략의 일부이다.

## S: 단일 책임의 원칙(SRP, Single responsibility principle)

- 하나의 클래스는 하나의 기능을 가지고, 전체 서비스에서 하나의 책임을 가지도록 설계하여야 한다는 원칙이다.
- 다른 원칙 및 OCP원리의 기초가 되며, 개념적으로는 간단하나 실제로 적용하기 어려운 원칙이다.

### SRP 적용방법

- 여러 책임을 가지고 있는 클래스가 있다면, 단일 책임을 갖는 클래스로 분리한다.
  - 즉, 결합도가 높은 클래스는 분리시켜 결합도를 낮춘다.
- 비슷한 책임을 가진 클래스가 흩어져 있다면, 하나의 클래스에 책임을 모은다.
  - 즉, 응집력이 높은 여러 클래스는 응집시켜 복잡도를 낮춘다.
- 클래스의 이름은 그 클래스가 가지고 있는 책임을 가장 잘 나타내는 이름으로 정해야 한다.
  - 반대로 생각해보면 클래스는 자신의 이름이 나타내고 있는 역할 만 해야한다.

## O: 개방폐쇄의 원칙(OCP, Open Close Principle)

- 소프트웨어의 구성요소는 확장에는 열려있고, 수정에는 닫혀있어야 한다는 원칙이다.
  - 기존 구성요소를 재사용하여 확장을 쉽게한다.
  - 요구사항의 변경 및 추가사항이 발생해도 기존의 구성요소는 수정되지 말아야 한다.
- 소프트웨어의 구성요소로란 컴포넌트, 모듈, 클래스, 함수 등을 말한다.

### OCP 적용방법

- 추상화와 다형성을 이용해 OCP를 적용한다.
  - 인터페이스를 이용하여 추상화와 다형성을 만족 시킬 수 있다.
- 확장 가능성이 있는 곳을 인터페이스에 의존하도록 코드를 작성한다.
  - 수정이 발생하였을 경우 같은 인터페이스를 상속받은 다른 코드로 교체가 용이해 진다.

### OCP 적용의 주의점

- 확장 가능성이 있는 곳과 없는 곳의 구분 기준을 잘 정해야 한다.
  - 확장 가능성이 있는 곳이 많다 -> 인터페이스가 많아진다 -> 복잡도가 상승한다.
- 인터페이스는 가능한 변경되지 말아야 하므로, 정의시 여러 경우의 수를 생각해야 한다.
- 인터페이스를 적당한 추상화 레벨로 정의해야 한다.
- **위의 주의점은 상황에 따라 다르기때문에 많은 경험이 필요하다.**

## L: 리스코브 치환의 원칙(LSP, The Liskov Substitution Principle)

- 서브 타입은 언제나 상위 타입으로 교체 가능 하여야 한다는 원칙이다.
- 다형성과 확장성을 위해 선언은 상위 타입으로, 생성은 서브 타입으로 한다.

### LSP 적용방법

- 상속이나 구현을 이용하여 적용한다.
- Is-A관계가 아니여서 LSP를 적용하기 힘들면 합성을 이용한다.
  - 일반적으로 Has-A관계

## I: 인터페이스 분리의 원칙(ISP, Interface Segregation Principle)

- 클래스는 자신이 사용하지 않는 인터페이스를 구현하지 말아야 한다는 원칙이다.
  - 하나의 범용적 인터페이스 보다 여러개의 구체적인 인터페이스를!
- SRP가 클래스의 단일 책임을 나타낸다면, ISP는 인터페이스의 단일 책임을 나타낸다.

### ISP 적용방법

- 클래스의 구현 인터페이스를 이용한 인터페이스 분리
- 객체의 인터페이스를 이용한 인터페이스 분리
  - 위임을 이용한 인터페이스 분리 (위임: 특정한 일의 책임을 그 일을 실행하는 객체에 맡기는 행위)

## D: 의존성역전의 원칙(DIP, Dependency Inversion Principle)

- 상위 모듈은 하위 모듈에 의존해서는 안된다는 원칙이다.
  - 상위 모듈이란 추상화도가 상대적으로 높은 모듈을 말한다. (ex. 자동차)
  - 하위 모듈이란 추상화도가 상대적으로 낮은 모듈을 말한다. (ex. 핸들, 타이어, 엔진 등)
  - 하위 모듈을 합성하여 상위 모듈을 만든다.

### DIP 적용방법

- 상위 모듈과 하위 모듈 모두 추상화에 의존시킨다. 
  - ex. 상위 모듈: 자동차, 추상화: 타이어, 하위 모듈: 스노우 타이어 
  - 추상화에 의존시킴으로서 하위 모듈의 변경이 상위 모듈에 영향을 주지 않게 된다.
- 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다.

## 참고

- [위키피디아 > SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))
- [Nextree > 객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)
- [위키피디아 > 의존관계 역전 원칙](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99)