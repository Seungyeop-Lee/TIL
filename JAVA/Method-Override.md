# 메소드 재정의(Method Override)

- 상속이나 구현을 할 경우, 상속 또는 구현의 대상이 가지고 있는 메소드를 재정의하여 사용하는 것을 의미한다.
- 인터페이스나 추상 클래스가 가지고 있는 추상 메소드의 경우는 메소드 재정의가 필수다.
  - 재정의하지 않을 시 컴파일 에러 발생

## 메소드 재정의 방법 및 규칙

- 이하의 규칙을 준수하여 메소드를 선언 및 정의하는 것으로 메소드 재정의가 가능하다.
  - 재정의 대상 메소드와 동일한 시그니처를 가져야 한다.
    - 시그니처(signature)란 메소드 이름, 매개 변수 리스트를 의미　(리턴 타입은 포함하지 않는다!)
  - 리턴 타입은 동일 타입이거나 하위 타입이어야 한다.
    - 재정의 대상 메소드의 리턴 타입 : `Object` -> 재정의 메소드의 접근 제한자 : `Object` 또는 `Object`를 상속하고 있는 모든 타입
  - 접근 제한자는 동일하거나 더 약한 접근 제한자를 사용해야 한다.
    - 재정의 대상 메소드의 접근 제한자 : `protected` -> 재정의 메소드의 접근 제한자 : `protected` 또는 `public`
  - 재정의 대상 메소드가 throw하고 있는 예외 이외의 새로운 예외를 throw 할 수 없다.
    - 재정의 대상 메소드가 throw하고 있는 예외의 생략은 가능

## `@Override`

- `@Override`를 재정의 메소드에 붙일경우, 컴파일 시에 메소드 재정의 유무를 확인한다.
  - 재정의 된 메소드가 아닐경우 컴파일 에러 발생
- `@Override`를 붙이지 않아도, 메소드 재정의 규칙만 준수하면 메소드 재정의가 이루어 진다.
- `@Override`를 이용하면 유지보수에 용의하기 때문에 꼭 사용하는 것이 바람직하다.
  - 메소드 재정의 시, 오타 발생이나 메소드 재정의 규칙을 준수하지 않을 경우, 메소드 재정의가 아닌 새로운 메소드의 정의로 다루어 짐
    - 상기의 원인으로 인해 버그가 발생 할 경우, 버그 해결이 어려움
  - `@Override`은 해당 메소드가 재정의 된 메소드임을 명시하기 때문에 코드 파악에 용의
    - `@Override`를 사용하지 않을 경우, 해당 클래스가 상속, 구현한 모든 클래스, 인터페이스를 파악해야 재정의 유무를 알 수 있음

## `super`

- 부모 객체의 참조값에 접근 가능한 키워드이다.
- `super`를 이용 할 경우, 부모 객체가 가지고 있는 재정의 되기 전 메소드의 호출이 가능하다.
  - `super.부모메소드();`

## 출처

- [이것이 자바다](http://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937)